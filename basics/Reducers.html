<!DOCTYPE html>
<html>
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta charset="utf-8">
<title>Reducers - Redux Documents</title>
<meta name="description" content="">
<meta name="author" content="">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1">
<link rel="stylesheet" href="../assets/css/bulma.min.css">
<link rel="stylesheet" href="../assets/css/app.css">
<!--[if lt IE 9]>
<script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.2/html5shiv.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/respond.js/1.4.2/respond.min.js"></script>
<![endif]-->
<link rel="shortcut icon" href="">
</head>
<body>

<nav class="columns navbar">
  <div class="column logo is-3 is-offset-1">
    <a class="is-brand" href="../index.html">
      Redux Documents
    </a>
  </div>
</nav>

<div class="columns content">
  <div class="column is-2-desktop is-3-widescreen is-hidden-touch">
  </div>
  <div class="column article-container is-11-tablet is-8-desktop is-6-widescreen">
    <div class="breadcrumb-area"><a href="../index.html" class="breadcrumb-item">Home</a><span class="breadcrumb-delimiter"> &gt; </span><a href="../basics/index.html" class="breadcrumb-item">basics</a><span class="breadcrumb-delimiter"> &gt; </span><a href="../basics/Reducers.html" class="breadcrumb-item">Reducers</a></div>
    <h1 class="article-title">Reducers</h1>
    <div class="article">
      <p><a href="./Actions.md">Actions</a> describe the fact that <em>something happened</em>, but don't specify how the application's state changes in response. This is the job of reducers.</p>
<h2 id="designing-the-state-shape">Designing the State Shape <a class="markdownIt-Anchor" href="#designing-the-state-shape">#</a></h2>
<p>In Redux, all the application state is stored as a single object. It's a good idea to think of its shape before writing any code. What's the minimal representation of your app's state as an object?</p>
<p>For our todo app, we want to store two different things:</p>
<ul>
<li>The currently selected visibility filter;</li>
<li>The actual list of todos.</li>
</ul>
<p>You'll often find that you need to store some data, as well as some UI state, in the state tree. This is fine, but try to keep the data separate from the UI state.</p>
<pre class="hljs"><code>{
  <span class="hljs-attr">visibilityFilter</span>: <span class="hljs-string">'SHOW_ALL'</span>,
  <span class="hljs-attr">todos</span>: [
    {
      <span class="hljs-attr">text</span>: <span class="hljs-string">'Consider using Redux'</span>,
      <span class="hljs-attr">completed</span>: <span class="hljs-literal">true</span>,
    },
    {
      <span class="hljs-attr">text</span>: <span class="hljs-string">'Keep all state in a single tree'</span>,
      <span class="hljs-attr">completed</span>: <span class="hljs-literal">false</span>
    }
  ]
}
</code></pre>
<blockquote>
<h5 id="note-on-relationships">Note on Relationships <a class="markdownIt-Anchor" href="#note-on-relationships">#</a></h5>
</blockquote>
<blockquote>
<p>In a more complex app, you're going to want different entities to reference each other. We suggest that you keep your state as normalized as possible, without any nesting. Keep every entity in an object stored with an ID as a key, and use IDs to reference it from other entities, or lists. Think of the app's state as a database. This approach is described in <a href="https://github.com/gaearon/normalizr">normalizr's</a> documentation in detail. For example, keeping <code>todosById: { id -&gt; todo }</code> and <code>todos: array&lt;id&gt;</code> inside the state would be a better idea in a real app, but we're keeping the example simple.</p>
</blockquote>
<h2 id="handling-actions">Handling Actions <a class="markdownIt-Anchor" href="#handling-actions">#</a></h2>
<p>Now that we've decided what our state object looks like, we're ready to write a reducer for it. The reducer is a pure function that takes the previous state and an action, and returns the next state.</p>
<pre class="hljs"><code>(previousState, action) =&gt; newState
</code></pre>
<p>It's called a reducer because it's the type of function you would pass to <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce"><code>Array.prototype.reduce(reducer, ?initialValue)</code></a>. It's very important that the reducer stays pure. Things you should <strong>never</strong> do inside a reducer:</p>
<ul>
<li>Mutate its arguments;</li>
<li>Perform side effects like API calls and routing transitions;</li>
<li>Call non-pure functions, e.g. <code>Date.now()</code> or <code>Math.random()</code>.</li>
</ul>
<p>We'll explore how to perform side effects in the <a href="../advanced/README.md">advanced walkthrough</a>. For now, just remember that the reducer must be pure. <strong>Given the same arguments, it should calculate the next state and return it. No surprises. No side effects. No API calls. No mutations. Just a calculation.</strong></p>
<p>With this out of the way, let's start writing our reducer by gradually teaching it to understand the <a href="Actions.md">actions</a> we defined earlier.</p>
<p>We'll start by specifying the initial state. Redux will call our reducer with an <code>undefined</code> state for the first time. This is our chance to return the initial state of our app:</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> { VisibilityFilters } <span class="hljs-keyword">from</span> <span class="hljs-string">'./actions'</span>

<span class="hljs-keyword">const</span> initialState = {
  <span class="hljs-attr">visibilityFilter</span>: VisibilityFilters.SHOW_ALL,
  <span class="hljs-attr">todos</span>: []
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">todoApp</span>(<span class="hljs-params">state, action</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> state === <span class="hljs-string">'undefined'</span>) {
    <span class="hljs-keyword">return</span> initialState
  }

  <span class="hljs-comment">// For now, don't handle any actions</span>
  <span class="hljs-comment">// and just return the state given to us.</span>
  <span class="hljs-keyword">return</span> state
}
</code></pre>
<p>One neat trick is to use the <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/default_parameters">ES6 default arguments syntax</a> to write this in a more compact way:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">todoApp</span>(<span class="hljs-params">state = initialState, action</span>) </span>{
  <span class="hljs-comment">// For now, don't handle any actions</span>
  <span class="hljs-comment">// and just return the state given to us.</span>
  <span class="hljs-keyword">return</span> state
}
</code></pre>
<p>Now let's handle <code>SET_VISIBILITY_FILTER</code>. All it needs to do is to change <code>visibilityFilter</code> on the state. Easy:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">todoApp</span>(<span class="hljs-params">state = initialState, action</span>) </span>{
  <span class="hljs-keyword">switch</span> (action.type) {
    <span class="hljs-keyword">case</span> SET_VISIBILITY_FILTER:
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.assign({}, state, {
        <span class="hljs-attr">visibilityFilter</span>: action.filter
      })
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">return</span> state
  }
}
</code></pre>
<p>Note that:</p>
<ol>
<li>
<p><strong>We don't mutate the <code>state</code>.</strong> We create a copy with <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign"><code>Object.assign()</code></a>. <code>Object.assign(state, { visibilityFilter: action.filter })</code> is also wrong: it will mutate the first argument. You <strong>must</strong> supply an empty object as the first parameter. You can also enable the <a href="../recipes/UsingObjectSpreadOperator.md">object spread operator proposal</a> to write <code>{ ...state, ...newState }</code> instead.</p>
</li>
<li>
<p><strong>We return the previous <code>state</code> in the <code>default</code> case.</strong> It's important to return the previous <code>state</code> for any unknown action.</p>
</li>
</ol>
<blockquote>
<h5 id="note-on-objectassign">Note on <code>Object.assign</code> <a class="markdownIt-Anchor" href="#note-on-objectassign">#</a></h5>
</blockquote>
<blockquote>
<p><a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign"><code>Object.assign()</code></a> is a part of ES6, but is not implemented by most browsers yet. You'll need to either use a polyfill, a <a href="https://www.npmjs.com/package/babel-plugin-transform-object-assign">Babel plugin</a>, or a helper from another library like <a href="https://lodash.com/docs#assign"><code>_.assign()</code></a>.</p>
</blockquote>
<blockquote>
<h5 id="note-on-switch-and-boilerplate">Note on <code>switch</code> and Boilerplate <a class="markdownIt-Anchor" href="#note-on-switch-and-boilerplate">#</a></h5>
</blockquote>
<blockquote>
<p>The <code>switch</code> statement is <em>not</em> the real boilerplate. The real boilerplate of Flux is conceptual: the need to emit an update, the need to register the Store with a Dispatcher, the need for the Store to be an object (and the complications that arise when you want a universal app). Redux solves these problems by using pure reducers instead of event emitters.</p>
</blockquote>
<blockquote>
<p>It's unfortunate that many still choose a framework based on whether it uses <code>switch</code> statements in the documentation. If you don't like <code>switch</code>, you can use a custom <code>createReducer</code> function that accepts a handler map, as shown in <a href="../recipes/ReducingBoilerplate.md#reducers">“reducing boilerplate”</a>.</p>
</blockquote>
<h2 id="handling-more-actions">Handling More Actions <a class="markdownIt-Anchor" href="#handling-more-actions">#</a></h2>
<p>We have two more actions to handle! Just like we did with <code>SET_VISIBILITY_FILTER</code>, we'll import the <code>ADD_TODO</code> and <code>TOGGLE_TODO</code> actions and then extend our reducer to handle <code>ADD_TODO</code>.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">todoApp</span>(<span class="hljs-params">state = initialState, action</span>) </span>{
  <span class="hljs-keyword">switch</span> (action.type) {
    <span class="hljs-keyword">case</span> SET_VISIBILITY_FILTER:
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.assign({}, state, {
        <span class="hljs-attr">visibilityFilter</span>: action.filter
      })
    <span class="hljs-keyword">case</span> ADD_TODO:
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.assign({}, state, {
        <span class="hljs-attr">todos</span>: [
          ...state.todos,
          {
            <span class="hljs-attr">text</span>: action.text,
            <span class="hljs-attr">completed</span>: <span class="hljs-literal">false</span>
          }
        ]
      })    
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">return</span> state
  }
}
</code></pre>
<p>Just like before, we never write directly to <code>state</code> or its fields, and instead we return new objects. The new <code>todos</code> is equal to the old <code>todos</code> concatenated with a single new item at the end. The fresh todo was constructed using the data from the action.</p>
<p>Finally, the implementation of the <code>TOGGLE_TODO</code> handler shouldn't come as a complete surprise:</p>
<pre class="hljs"><code><span class="hljs-keyword">case</span> TOGGLE_TODO:
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.assign({}, state, {
    <span class="hljs-attr">todos</span>: state.todos.map(<span class="hljs-function">(<span class="hljs-params">todo, index</span>) =&gt;</span> {
      <span class="hljs-keyword">if</span> (index === action.index) {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.assign({}, todo, {
          <span class="hljs-attr">completed</span>: !todo.completed
        })
      }
      <span class="hljs-keyword">return</span> todo
    })
  })
</code></pre>
<p>Because we want to update a specific item in the array without resorting to mutations, we have to create a new array with the same items except the item at the index. If you find yourself often writing such operations, it's a good idea to use a helper like <a href="https://github.com/kolodny/immutability-helper">immutability-helper</a>, <a href="https://github.com/substantial/updeep">updeep</a>, or even a library like <a href="http://facebook.github.io/immutable-js/">Immutable</a> that has native support for deep updates. Just remember to never assign to anything inside the <code>state</code> unless you clone it first.</p>
<h2 id="splitting-reducers">Splitting Reducers <a class="markdownIt-Anchor" href="#splitting-reducers">#</a></h2>
<p>Here is our code so far. It is rather verbose:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">todoApp</span>(<span class="hljs-params">state = initialState, action</span>) </span>{
  <span class="hljs-keyword">switch</span> (action.type) {
    <span class="hljs-keyword">case</span> SET_VISIBILITY_FILTER:
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.assign({}, state, {
        <span class="hljs-attr">visibilityFilter</span>: action.filter
      })
    <span class="hljs-keyword">case</span> ADD_TODO:
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.assign({}, state, {
        <span class="hljs-attr">todos</span>: [
          ...state.todos,
          {
            <span class="hljs-attr">text</span>: action.text,
            <span class="hljs-attr">completed</span>: <span class="hljs-literal">false</span>
          }
        ]
      })
    <span class="hljs-keyword">case</span> TOGGLE_TODO:
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.assign({}, state, {
        <span class="hljs-attr">todos</span>: state.todos.map(<span class="hljs-function">(<span class="hljs-params">todo, index</span>) =&gt;</span> {
          <span class="hljs-keyword">if</span>(index === action.index) {
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.assign({}, todo, {
              <span class="hljs-attr">completed</span>: !todo.completed
            })
          }
          <span class="hljs-keyword">return</span> todo
        })
      })
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">return</span> state
  }
}
</code></pre>
<p>Is there a way to make it easier to comprehend? It seems like <code>todos</code> and <code>visibilityFilter</code> are updated completely independently. Sometimes state fields depend on one another and more consideration is required, but in our case we can easily split updating <code>todos</code> into a separate function:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">todos</span>(<span class="hljs-params">state = [], action</span>) </span>{
  <span class="hljs-keyword">switch</span> (action.type) {
    <span class="hljs-keyword">case</span> ADD_TODO:
      <span class="hljs-keyword">return</span> [
        ...state,
        {
          <span class="hljs-attr">text</span>: action.text,
          <span class="hljs-attr">completed</span>: <span class="hljs-literal">false</span>
        }
      ]
    <span class="hljs-keyword">case</span> TOGGLE_TODO:
      <span class="hljs-keyword">return</span> state.map(<span class="hljs-function">(<span class="hljs-params">todo, index</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span> (index === action.index) {
          <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.assign({}, todo, {
            <span class="hljs-attr">completed</span>: !todo.completed
          })
        }
        <span class="hljs-keyword">return</span> todo
      })
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">return</span> state
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">todoApp</span>(<span class="hljs-params">state = initialState, action</span>) </span>{
  <span class="hljs-keyword">switch</span> (action.type) {
    <span class="hljs-keyword">case</span> SET_VISIBILITY_FILTER:
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.assign({}, state, {
        <span class="hljs-attr">visibilityFilter</span>: action.filter
      })
    <span class="hljs-keyword">case</span> ADD_TODO:
    <span class="hljs-keyword">case</span> TOGGLE_TODO:
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.assign({}, state, {
        <span class="hljs-attr">todos</span>: todos(state.todos, action)
      })
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">return</span> state
  }
}
</code></pre>
<p>Note that <code>todos</code> also accepts <code>state</code>—but it's an array! Now <code>todoApp</code> just gives it the slice of the state to manage, and <code>todos</code> knows how to update just that slice. <strong>This is called <em>reducer composition</em>, and it's the fundamental pattern of building Redux apps.</strong></p>
<p>Let's explore reducer composition more. Can we also extract a reducer managing just <code>visibilityFilter</code>? We can.</p>
<p>Below our imports, let's use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">ES6 Object Destructuring</a> to declare <code>SHOW_ALL</code>:</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> { SHOW_ALL } = VisibilityFilters;
</code></pre>
<p>Then:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visibilityFilter</span>(<span class="hljs-params">state = SHOW_ALL, action</span>) </span>{
  <span class="hljs-keyword">switch</span> (action.type) {
    <span class="hljs-keyword">case</span> SET_VISIBILITY_FILTER:
      <span class="hljs-keyword">return</span> action.filter
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">return</span> state
  }
}
</code></pre>
<p>Now we can rewrite the main reducer as a function that calls the reducers managing parts of the state, and combines them into a single object. It also doesn't need to know the complete initial state anymore. It's enough that the child reducers return their initial state when given <code>undefined</code> at first.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">todos</span>(<span class="hljs-params">state = [], action</span>) </span>{
  <span class="hljs-keyword">switch</span> (action.type) {
    <span class="hljs-keyword">case</span> ADD_TODO:
      <span class="hljs-keyword">return</span> [
        ...state,
        {
          <span class="hljs-attr">text</span>: action.text,
          <span class="hljs-attr">completed</span>: <span class="hljs-literal">false</span>
        }
      ]
    <span class="hljs-keyword">case</span> TOGGLE_TODO:
      <span class="hljs-keyword">return</span> state.map(<span class="hljs-function">(<span class="hljs-params">todo, index</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span> (index === action.index) {
          <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.assign({}, todo, {
            <span class="hljs-attr">completed</span>: !todo.completed
          })
        }
        <span class="hljs-keyword">return</span> todo
      })
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">return</span> state
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visibilityFilter</span>(<span class="hljs-params">state = SHOW_ALL, action</span>) </span>{
  <span class="hljs-keyword">switch</span> (action.type) {
    <span class="hljs-keyword">case</span> SET_VISIBILITY_FILTER:
      <span class="hljs-keyword">return</span> action.filter
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">return</span> state
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">todoApp</span>(<span class="hljs-params">state = {}, action</span>) </span>{
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">visibilityFilter</span>: visibilityFilter(state.visibilityFilter, action),
    <span class="hljs-attr">todos</span>: todos(state.todos, action)
  }
}
</code></pre>
<p><strong>Note that each of these reducers is managing its own part of the global state. The <code>state</code> parameter is different for every reducer, and corresponds to the part of the state it manages.</strong></p>
<p>This is already looking good! When the app is larger, we can split the reducers into separate files and keep them completely independent and managing different data domains.</p>
<p>Finally, Redux provides a utility called <a href="../api/combineReducers.md"><code>combineReducers()</code></a> that does the same boilerplate logic that the <code>todoApp</code> above currently does. With its help, we can rewrite <code>todoApp</code> like this:</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> { combineReducers } <span class="hljs-keyword">from</span> <span class="hljs-string">'redux'</span>

<span class="hljs-keyword">const</span> todoApp = combineReducers({
  visibilityFilter,
  todos
})

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> todoApp
</code></pre>
<p>Note that this is equivalent to:</p>
<pre class="hljs"><code><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">todoApp</span>(<span class="hljs-params">state = {}, action</span>) </span>{
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">visibilityFilter</span>: visibilityFilter(state.visibilityFilter, action),
    <span class="hljs-attr">todos</span>: todos(state.todos, action)
  }
}
</code></pre>
<p>You could also give them different keys, or call functions differently. These two ways to write a combined reducer are equivalent:</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> reducer = combineReducers({
  <span class="hljs-attr">a</span>: doSomethingWithA,
  <span class="hljs-attr">b</span>: processB,
  <span class="hljs-attr">c</span>: c
})
</code></pre>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reducer</span>(<span class="hljs-params">state = {}, action</span>) </span>{
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">a</span>: doSomethingWithA(state.a, action),
    <span class="hljs-attr">b</span>: processB(state.b, action),
    <span class="hljs-attr">c</span>: c(state.c, action)
  }
}
</code></pre>
<p>All <a href="../api/combineReducers.md"><code>combineReducers()</code></a> does is generate a function that calls your reducers <strong>with the slices of state selected according to their keys</strong>, and combining their results into a single object again. <a href="https://github.com/reactjs/redux/issues/428#issuecomment-129223274">It's not magic.</a> And like other reducers, <code>combineReducers()</code> does not create a new object if all of the reducers provided to it do not change state.</p>
<blockquote>
<h5 id="note-for-es6-savvy-users">Note for ES6 Savvy Users <a class="markdownIt-Anchor" href="#note-for-es6-savvy-users">#</a></h5>
</blockquote>
<blockquote>
<p>Because <code>combineReducers</code> expects an object, we can put all top-level reducers into a separate file, <code>export</code> each reducer function, and use <code>import * as reducers</code> to get them as an object with their names as the keys:</p>
</blockquote>
<blockquote>
<pre class="hljs"><code><span class="hljs-keyword">import</span> { combineReducers } <span class="hljs-keyword">from</span> <span class="hljs-string">'redux'</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> reducers <span class="hljs-keyword">from</span> <span class="hljs-string">'./reducers'</span>

<span class="hljs-keyword">const</span> todoApp = combineReducers(reducers)
</code></pre>
<p>Because <code>import *</code> is still new syntax, we don't use it anymore in the documentation to avoid <a href="https://github.com/reactjs/redux/issues/428#issuecomment-129223274">confusion</a>, but you may encounter it in some community examples.</p>
</blockquote>
<h2 id="source-code">Source Code <a class="markdownIt-Anchor" href="#source-code">#</a></h2>
<h4 id="reducersjs"><code>reducers.js</code> <a class="markdownIt-Anchor" href="#reducersjs">#</a></h4>
<pre class="hljs"><code><span class="hljs-keyword">import</span> { combineReducers } <span class="hljs-keyword">from</span> <span class="hljs-string">'redux'</span>
<span class="hljs-keyword">import</span> { ADD_TODO, TOGGLE_TODO, SET_VISIBILITY_FILTER, VisibilityFilters } <span class="hljs-keyword">from</span> <span class="hljs-string">'./actions'</span>
<span class="hljs-keyword">const</span> { SHOW_ALL } = VisibilityFilters

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visibilityFilter</span>(<span class="hljs-params">state = SHOW_ALL, action</span>) </span>{
  <span class="hljs-keyword">switch</span> (action.type) {
    <span class="hljs-keyword">case</span> SET_VISIBILITY_FILTER:
      <span class="hljs-keyword">return</span> action.filter
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">return</span> state
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">todos</span>(<span class="hljs-params">state = [], action</span>) </span>{
  <span class="hljs-keyword">switch</span> (action.type) {
    <span class="hljs-keyword">case</span> ADD_TODO:
      <span class="hljs-keyword">return</span> [
        ...state,
        {
          <span class="hljs-attr">text</span>: action.text,
          <span class="hljs-attr">completed</span>: <span class="hljs-literal">false</span>
        }
      ]
    <span class="hljs-keyword">case</span> TOGGLE_TODO:
      <span class="hljs-keyword">return</span> state.map(<span class="hljs-function">(<span class="hljs-params">todo, index</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span> (index === action.index) {
          <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.assign({}, todo, {
            <span class="hljs-attr">completed</span>: !todo.completed
          })
        }
        <span class="hljs-keyword">return</span> todo
      })
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">return</span> state
  }
}

<span class="hljs-keyword">const</span> todoApp = combineReducers({
  visibilityFilter,
  todos
})

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> todoApp
</code></pre>
<h2 id="next-steps">Next Steps <a class="markdownIt-Anchor" href="#next-steps">#</a></h2>
<p>Next, we'll explore how to <a href="Store.md">create a Redux store</a> that holds the state and takes care of calling your reducer when you dispatch an action.</p>

      
    </div>
    <div class="level article-bar is-mobile">
      <div class="level-item has-text-centered">
        <a title="previous page" class="previouse-article-link" href="../basics/Actions.html"><span class="icon icon-previous" data-icon="previous"></span><span class="link-content">&laquo; Previous</span></a>
      </div>
      <div class="level-item has-text-centered">
        <a title="font size" class="link-item link-item-size">
          <span class="icon icon-size" data-icon="size"></span>
        </a>
      </div>
      <div class="level-item has-text-centered">
        <a title="table of content" class="link-item link-item-toc">
          <span class="icon icon-toc" data-icon="toc"></span>
        </a>
      </div>
      <div class="level-item has-text-centered">
        <a title="top" href="#">
          <span class="icon icon-up" data-icon="up"></span>
          <span class="link-content">⤊ Top</span>
        </a>
      </div>
      <div class="level-item has-text-centered">
        <a title="next page" class="next-article-link" href="../basics/Store.html"><span class="icon icon-next" data-icon="next"></span><span class="link-content">Next &raquo;</span></a>
      </div>
    </div>
  </div>
  <div class="column is-2-widescreen is-hidden">
  </div>
</div>

<div class="columns foot">
  <div class="column is-3 is-offset-9 build-by">
    Build by <a href="https://github.com/ruanyf/loppo" target="_blank">Loppo</a> 0.3.0
  </div>
</div>

<div class="book-toc notification is-warning is-hidden">
  <h3>Table of chapters &nbsp;<span class="title-close"><a class="button is-danger"> Close </a></span></h3>
  <ul class="chapter-area"><li class="chapter-item "><a href="../introduction/index.html">introduction</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item "><a href="../introduction/Motivation.html">Motivation</a></li><li class="chapter-item "><a href="../introduction/ThreePrinciples.html">Three Principles</a></li><li class="chapter-item "><a href="../introduction/PriorArt.html">Prior Art</a></li><li class="chapter-item "><a href="../introduction/CoreConcepts.html">Core Concepts</a></li><li class="chapter-item "><a href="../introduction/Ecosystem.html">Ecosystem</a></li><li class="chapter-item "><a href="../introduction/Examples.html">Examples</a></li></ul><li class="chapter-item "><a href="../basics/index.html">basics</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-collapse" data-icon="collapse"></span></a></li><ul class="chapter-level-1 chapter-level-1-current"><li class="chapter-item "><a href="../basics/Actions.html">Actions</a></li><li class="chapter-item chapter-item-current"><a href="../basics/Reducers.html">Reducers</a></li><li class="chapter-item "><a href="../basics/Store.html">Store</a></li><li class="chapter-item "><a href="../basics/DataFlow.html">Data Flow</a></li><li class="chapter-item "><a href="../basics/UsageWithReact.html">Usage with React</a></li><li class="chapter-item "><a href="../basics/ExampleTodoList.html">Example: Todo List</a></li></ul><li class="chapter-item "><a href="../advanced/index.html">advanced</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item "><a href="../advanced/AsyncActions.html">Async Actions</a></li><li class="chapter-item "><a href="../advanced/AsyncFlow.html">Async Flow</a></li><li class="chapter-item "><a href="../advanced/ExampleRedditAPI.html">Example: Reddit API</a></li><li class="chapter-item "><a href="../advanced/Middleware.html">Middleware</a></li><li class="chapter-item "><a href="../advanced/NextSteps.html">Next Steps</a></li><li class="chapter-item "><a href="../advanced/UsageWithReactRouter.html">Usage with React Router</a></li></ul><li class="chapter-item "><a href="../recipes/index.html">recipes</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item "><a href="../recipes/ComputingDerivedData.html">Computing Derived Data</a></li><li class="chapter-item "><a href="../recipes/ImplementingUndoHistory.html">Implementing Undo History</a></li><li class="chapter-item "><a href="../recipes/IsolatingSubapps.html">Isolating Redux Sub-Apps</a></li><li class="chapter-item "><a href="../recipes/MigratingToRedux.html">Migrating to Redux</a></li><li class="chapter-item "><a href="../recipes/ReducingBoilerplate.html">Reducing Boilerplate</a></li><li class="chapter-item "><a href="../recipes/ServerRendering.html">Server Rendering</a></li><li class="chapter-item "><a href="../recipes/StructuringReducers.html">Structuring Reducers</a></li><li class="chapter-item "><a href="../recipes/UsingObjectSpreadOperator.html">Using Object Spread Operator</a></li><li class="chapter-item "><a href="../recipes/WritingTests.html">Writing Tests</a></li><li class="chapter-item "><a href="../recipes/reducers/index.html">reducers</a></li><ul class="chapter-level-2"><li class="chapter-item "><a href="../recipes/reducers/BasicReducerStructure.html">Basic Reducer Structure and State Shape</a></li><li class="chapter-item "><a href="../recipes/reducers/BeyondCombineReducers.html">Beyond `combineReducers`</a></li><li class="chapter-item "><a href="../recipes/reducers/ImmutableUpdatePatterns.html">Immutable Update Patterns</a></li><li class="chapter-item "><a href="../recipes/reducers/InitializingState.html">Initializing State</a></li><li class="chapter-item "><a href="../recipes/reducers/NormalizingStateShape.html">Normalizing State Shape</a></li><li class="chapter-item "><a href="../recipes/reducers/PrerequisiteConcepts.html">Prerequisite Reducer Concepts</a></li><li class="chapter-item "><a href="../recipes/reducers/RefactoringReducersExample.html">Refactoring Reducer Logic Using Functional Decomposition and Reducer Composition</a></li><li class="chapter-item "><a href="../recipes/reducers/ReusingReducerLogic.html">Reusing Reducer Logic</a></li><li class="chapter-item "><a href="../recipes/reducers/SplittingReducerLogic.html">Splitting Up Reducer Logic</a></li><li class="chapter-item "><a href="../recipes/reducers/UpdatingNormalizedData.html">Managing Normalized Data</a></li><li class="chapter-item "><a href="../recipes/reducers/UsingCombineReducers.html">Using `combineReducers`</a></li></ul><li class="chapter-item "><a href="../faq/index.html">faq</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><li class="chapter-item "><a href="../faq/Actions.html">Redux FAQ: Actions</a></li><li class="chapter-item "><a href="../faq/CodeStructure.html">Redux FAQ: Code Structure</a></li><li class="chapter-item "><a href="../faq/General.html">Redux FAQ: General</a></li><li class="chapter-item "><a href="../faq/Miscellaneous.html">Redux FAQ: Miscellaneous</a></li><li class="chapter-item "><a href="../faq/OrganizingState.html">Redux FAQ: Organizing State</a></li><li class="chapter-item "><a href="../faq/Performance.html">Redux FAQ: Performance</a></li><li class="chapter-item "><a href="../faq/ReactRedux.html">Redux FAQ: React Redux</a></li><li class="chapter-item "><a href="../faq/Reducers.html">Redux FAQ: Reducers</a></li><li class="chapter-item "><a href="../faq/StoreSetup.html">Redux FAQ: Store Setup</a></li></ul><li class="chapter-item "><a href="../Troubleshooting.html">Troubleshooting</a></li><li class="chapter-item "><a href="../Glossary.html">Glossary</a></li><li class="chapter-item "><a href="../api/index.html">api</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item "><a href="../api/Store.html">Store</a></li><li class="chapter-item "><a href="../api/applyMiddleware.html">`applyMiddleware(...middlewares)`</a></li><li class="chapter-item "><a href="../api/bindActionCreators.html">`bindActionCreators(actionCreators, dispatch)`</a></li><li class="chapter-item "><a href="../api/combineReducers.html">`combineReducers(reducers)`</a></li><li class="chapter-item "><a href="../api/compose.html">`compose(...functions)`</a></li><li class="chapter-item "><a href="../api/createStore.html">`createStore(reducer, [preloadedState], [enhancer])`</a></li></ul><li class="chapter-item "><a href="../Feedback.html">Feedback</a></li></ul>
</div>

<!-- SCRIPTS -->
<script>
  var LOPPO = {};
  LOPPO.current_path = 'basics/Reducers.md';
  LOPPO.relative_root_path = '../';
  LOPPO.article_toc = "<ul class=\"markdownIt-TOC\">\n<li><a href=\"#designing-the-state-shape\">Designing the State Shape</a></li>\n<li><a href=\"#handling-actions\">Handling Actions</a></li>\n<li><a href=\"#handling-more-actions\">Handling More Actions</a></li>\n<li><a href=\"#splitting-reducers\">Splitting Reducers</a></li>\n<li><a href=\"#source-code\">Source Code</a></li>\n<li><a href=\"#next-steps\">Next Steps</a></li>\n</ul>\n";
</script>
<script src="../assets/js/app.js"></script>

</body>
</html>

